// This file was generated by SquareLine Studio
// SquareLine Studio version: SquareLine Studio 1.3.0
// LVGL version: 8.3.6
// Project name: SquareLine_Project

#include "../ui.h"
#include "jpeg_decoder.h"
#include "esp_log.h"
#include "esp_heap_caps.h"

void ui_Screen1_screen_init(void)
{
    ui_Screen1 = lv_obj_create(NULL);
    lv_obj_clear_flag( ui_Screen1, LV_OBJ_FLAG_SCROLLABLE );    /// Flags

    ui_Label2 = lv_label_create(ui_Screen1);
    lv_obj_set_width( ui_Label2, LV_SIZE_CONTENT);  /// 1
    lv_obj_set_height( ui_Label2, LV_SIZE_CONTENT);   /// 1
    lv_obj_set_x( ui_Label2, -2 );
    lv_obj_set_y( ui_Label2, 114 );
    lv_obj_set_align( ui_Label2, LV_ALIGN_CENTER );
    lv_label_set_text(ui_Label2,"Hello Paimon!");

    ui_Image2 = lv_img_create(ui_Screen1);
    lv_img_set_src(ui_Image2, &ui_img_aa_2_png);
    lv_obj_set_width( ui_Image2, LV_SIZE_CONTENT);  /// 1
    lv_obj_set_height( ui_Image2, LV_SIZE_CONTENT);   /// 1
    lv_obj_set_x( ui_Image2, 0 );
    lv_obj_set_y( ui_Image2, 0 );
    lv_obj_set_align( ui_Image2, LV_ALIGN_CENTER );
    lv_obj_add_flag( ui_Image2, LV_OBJ_FLAG_ADV_HITTEST );   /// Flags
    lv_obj_clear_flag( ui_Image2, LV_OBJ_FLAG_SCROLLABLE );    /// Flags
}

void updateVideoImage(unsigned char* imageData, int imageWidth, int imageHeight) {
    // Input image data
    // Allocate memory for the decoded image
    static const char *TAG = "video_update";
    size_t out_img_buf_size = imageWidth * imageHeight * 2;
    uint16_t *out_img_buf = (uint16_t *)heap_caps_malloc(out_img_buf_size, MALLOC_CAP_DMA);
    if (!out_img_buf) {
        ESP_LOGE(TAG, "Failed to allocate memory for decoded image");
        return;
    }

    // Set up the JPEG decoder configuration
    esp_jpeg_image_cfg_t jpeg_cfg = {
        .indata = imageData,
        .indata_size = imageWidth * imageHeight * 2, // You may need to update this value based on the actual JPEG data size
        .outbuf = out_img_buf,
        .outbuf_size = out_img_buf_size,
        .out_format = JPEG_IMAGE_FORMAT_RGB565,
        .out_scale = JPEG_IMAGE_SCALE_0,
        .flags = {
            .swap_color_bytes = 1,
        }
    };

    // Decode the JPEG image
    esp_jpeg_image_output_t outimg;
    int ret = esp_jpeg_decode(&jpeg_cfg, &outimg);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "JPEG decoding failed: %d", ret);
        free(out_img_buf);
        return;
    }

    // Update the image source for ui_Image2 with the decoded image
    const lv_img_dsc_t img_buffer = {
        .header.cf = LV_IMG_CF_TRUE_COLOR,
        .header.always_zero = 0,
        .header.w = outimg.width,
        .header.h = outimg.height,
        .data_size = (size_t)(outimg.width * outimg.height * LV_COLOR_SIZE / 8),
        .data = (const uint8_t *)out_img_buf,
    };

    // Update the image source for ui_Image2 to the new buffer
    lv_img_set_src(ui_Image2, &img_buffer);

    // Trigger a redraw of the image object
    lv_obj_invalidate(ui_Image2);

    // Free the memory for the decoded image
    free(out_img_buf);
}


